= Czytanie kodÃ³w 101 dla Magdy
:toc:
:toclevels: 4
:toc-title: Spis treÅ›ci

== Fragment ksiÄ…Å¼ki https://ksiegarnia.pwn.pl/Zrozumiec-programowanie,216633888,p.html["ZrozumieÄ‡ programowanie" Gynvael Coldwind]
=== Czytanie nieznanego jÄ™zyka
PracujÄ…c przy niewielkich projektach, czÄ™sto korzystamy tylko z jednego jÄ™zyka programowania, aÂ wiÄ™c jeÅ›li zachodzi potrzeba zrozumienia fragmentÃ³w jego kodu, mamy do czynienia jedynie zÂ jÄ™zykiem, ktÃ³ry iÂ tak juÅ¼ znamy. Taka sytuacja ma miejsce, kiedy musimy zapoznaÄ‡ siÄ™ zÂ kodem stworzonym przez inne osoby pracujÄ…ce przy naszym projekcie, zÂ kodem jednego zÂ uÅ¼ywanych komponentÃ³w lub ze swoim wÅ‚asnym, ktÃ³ry stworzyliÅ›my dawno temu iÂ nie do koÅ„ca pamiÄ™tamy, jak funkcjonowaÅ‚. Analogicznie sprawa ma siÄ™ wÂ przypadku czytania fragmentÃ³w innych projektÃ³w napisanych wÂ znanym nam jÄ™zyku, choÄ‡ wÂ tym wypadku odmienne reguÅ‚y formatowania oraz nieznane komponenty mogÄ… wyglÄ…daÄ‡ nieco egzotycznie iÂ spowolniÄ‡ analizÄ™.

Sprawa wyglÄ…da zupeÅ‚nie inaczej wÂ przypadku eksploracji wiÄ™kszych projektÃ³w â€“ wÂ takiej sytuacji bardzo szybko dociera siÄ™ do innych, niekoniecznie znanych nam (lub znanych wÂ niewielkim stopniu) jÄ™zykÃ³w oraz technologii. CzÄ™sto identycznie jest wÂ przypadku posiÅ‚kowania siÄ™ ÅºrÃ³dÅ‚ami Å›rodowiska wykonania (run-time/execution environment) danego jÄ™zyka oraz jego standardowych iÂ dodatkowych bibliotek. Jedynie wÂ nielicznych przypadkach szczegÃ³Å‚owy opis interesujÄ…cego nas fragmentu znajdziemy wÂ oficjalnej dokumentacji projektu.footnote:[Niestety praktyka pokazuje, Å¼e dokumentacja czÄ™sto jest niekompletna, nieaktualna, pomija interesujÄ…ce nas szczegÃ³Å‚y lub po prostu w ogÃ³le nie istnieje.], czÄ™Å›ciej  jednak bÄ™dziemy musieli siÄ™gaÄ‡ do ÅºrÃ³deÅ‚.

.Jak siÄ™ okazuje, czytanie iÂ stosunkowo prawidÅ‚owa interpretacja kodu wÂ nieznanym jÄ™zyku jest jak najbardziej moÅ¼liwa â€“ aÂ zÂ im wiÄ™kszÄ… ich liczbÄ… miaÅ‚o siÄ™ do czynienia, tym jest to Å‚atwiejsze. Wynika to zÂ kilku prostych czynnikÃ³w:
* JÄ™zyki programowania zÂ danej grupy paradygmatycznej footnote:[PrzykÅ‚adowym paradygmatem w kontekÅ›cie programowania jest np. programowanie obiektowe lub funkcyjne.] sÄ… czÄ™sto bardzo podobne skÅ‚adniowo, gramatycznie iÂ wÂ sposobie uÅ¼ycia.
* Nazwy funkcji, klas, metod, struktur, aÂ takÅ¼e sÅ‚owa kluczowe, dyrektywy itd. wÂ zdecydowanej wiÄ™kszoÅ›ci przypadkÃ³w skÅ‚adajÄ… siÄ™ zÂ poÅ‚Ä…czenia angielskich sÅ‚Ã³w lub ich skrÃ³tÃ³w. JuÅ¼ samo rozwiniÄ™cie skrÃ³tÃ³w iÂ przetÅ‚umaczenie wyrazÃ³w na jÄ™zyk polski niesie ze sobÄ… znacznÄ… porcjÄ™ informacji.
* Program to nie tylko sam kod, ale rÃ³wnieÅ¼ komentarze oraz dane (wÂ szczegÃ³lnoÅ›ci komunikaty oÂ bÅ‚Ä™dach), ktÃ³re czÄ™sto sÄ… bardzo wymowne.

OczywiÅ›cie od wszystkich wymienionych czynnikÃ³w istniejÄ… takÅ¼e wyjÄ…tki, natomiast wÂ wiÄ™kszoÅ›ci wypadkÃ³w juÅ¼ samo wykorzystanie wymienionych informacji iÂ wskazÃ³wek wystarcza do zrozumienia wybranego fragmentu. WÂ razie gdyby to jednak zawiodÅ‚o, pozostaje nam konsultacja zÂ ogÃ³lnodostÄ™pnÄ… dokumentacjÄ… danego jÄ™zyka, choÄ‡by wÂ formie tablic informatycznych (potocznie zwanych cheatsheetami).

==== PodobieÅ„stwa iÂ rÃ³Å¼nice

WÂ jÄ™zykach wywodzÄ…cych siÄ™ zÂ paradygmatÃ³w programowania proceduralnego czy obiektowego (na takich bowiem skupiam siÄ™ wÂ tej ksiÄ…Å¼ce) wiele wyraÅ¼eÅ„ ma albo identyczny, albo przynajmniej zbliÅ¼ony zapis. To samo dotyczy dostÄ™pnoÅ›ci rÃ³Å¼nych konstrukcji skÅ‚adniowych, ktÃ³rych lwia czÄ™Å›Ä‡ wystÄ™puje wÂ wiÄ™kszoÅ›ci jÄ™zykÃ³w zÂ tych rodzin.

Na przykÅ‚ad wÂ C, C+\+, Objective-C, Java, PHP, JavaScript, Perl oraz wÂ innych jÄ™zykach poczÄ…tek iÂ koniec bloku kodu oznacza siÄ™ znakami { oraz }. WyjÄ…tkiem od tej reguÅ‚y jest np. Python, wÂ ktÃ³rym oÂ przynaleÅ¼noÅ›ci do danego bloku decyduje gÅ‚Ä™bokoÅ›Ä‡ wciÄ™Ä‡. InnÄ… konwencjÄ™ przyjmuje rÃ³wnieÅ¼ Pascal, Delphi oraz ADA footnote:[ğŸ’˜], ktÃ³re wÂ tym celu uÅ¼ywajÄ… sÅ‚Ã³w kluczowych begin oraz end. Kolejnym przykÅ‚adem moÅ¼e byÄ‡ zapis wywoÅ‚ania funkcji â€“ praktycznie wÂ kaÅ¼dym jÄ™zyku zÂ tej grupy jest to po prostu nazwa funkcji, po ktÃ³rej nastÄ™puje lista rozdzielonych przecinkami parametrÃ³w umieszczonych wÂ okrÄ…gÅ‚ych nawiasach. NiektÃ³re jÄ™zyki (np. Ruby czy D) dopuszczajÄ… wÂ pewnych przypadkach pominiÄ™cie nawiasÃ³w. MoÅ¼na ich rÃ³wnieÅ¼ nie stosowaÄ‡ np. wÂ jÄ™zykach Python (2:7) oraz PHP wÂ przypadku dyrektywy print (wystÄ™pujÄ…cej wÂ obu tych jÄ™zykach), aÂ takÅ¼e wÂ niektÃ³rych zastosowaniach sizeof oraz typeof wÂ jÄ™zykach C oraz C++.

WyraÅ¼enia arytmetyczno-logiczne iÂ przypisanie wartoÅ›ci do zmiennej rÃ³wnieÅ¼ sÄ… wÂ zasadzie identyczne wÂ wiÄ™kszoÅ›ci jÄ™zykÃ³w (wyjÄ…tkiem jest np. Pascal, uÅ¼ywajÄ…cy digrafu := do oznaczenia przypisania). RÃ³Å¼nice wÂ tej kwestii dotyczÄ… gÅ‚Ã³wnie dostÄ™pnoÅ›ci iÂ sposobu oznaczenia niektÃ³rych operacji. Na przykÅ‚ad wyraÅ¼enie `aÂ = (2 + b) * 3` bÄ™dzie zapisane tak samo wÂ wiÄ™kszoÅ›ci jÄ™zykÃ³w, ale juÅ¼ znak dzielenia moÅ¼e oznaczaÄ‡ rÃ³Å¼ne dziaÅ‚ania. DokÅ‚adniej: wynikiem operacji `1 / 2` wÂ wiÄ™kszoÅ›ci jÄ™zykÃ³w bÄ™dzie 0, poniewaÅ¼ literaÅ‚y 1 oraz 2 zostanÄ… zinterpretowane jako staÅ‚e typu caÅ‚kowitego, aÂ wiÄ™c iÂ wynikiem dzielenia bÄ™dzie liczba caÅ‚kowita. WyjÄ…tkiem jest Pascal oraz Python 3, wÂ ktÃ³rych znak / oznacza konkretnie dzielenie na liczbach rzeczywistych footnote:[Dzielenie caÅ‚kowite w Pascalu moÅ¼na uzyskaÄ‡, uÅ¼ywajÄ…c sÅ‚owa kluczowego DIV, a w Python 3 za pomocÄ… operatora // (podwÃ³jny znak dzielenia). Ten sam digraf jest uÅ¼ywany jako poczÄ…tek komentarza w niektÃ³rych innych jÄ™zykach.] (aÂ Å›ciÅ›lej zmiennoprzecinkowych), aÂ takÅ¼e JavaScript, wÂ ktÃ³rym nie istnieje oddzielny typ dla liczb caÅ‚kowitych footnote:[Jak wspominam w czÄ™Å›ci II ksiÄ…Å¼ki, jedynym liczbowym typem w jÄ™zyku JavaScript jest zmiennoprzecinkowy typ Number, bÄ™dÄ…cy odpowiednikiem double w jÄ™zykach C, C++ czy Java, czy float w PHP oraz Python.] â€“ wÂ tych przypadkach wynikiem bÄ™dzie 0.5. IdÄ…c dalej: wÂ kilku jÄ™zykach wystÄ™puje operator potÄ™gowania, ktÃ³rego nie znajdziemy wÂ innych â€“ operacjÄ™ tÄ™ wÂ jÄ™zyku Python oznacza siÄ™ digrafem **, aÂ wÂ VB.NET znakiem ^ footnote:[UÅ¼ycie ^, czyli karety (popularnie zwanej â€daszkiemâ€) do oznaczenia potÄ™gowania moÅ¼e dziwiÄ‡, szczegÃ³lnie Å¼e w wiÄ™kszoÅ›ci jÄ™zykÃ³w znakiem tym oznacza siÄ™ bitowy XOR. Ma to podÅ‚oÅ¼e historyczne â€“ w Dartmouth BASIC (czyli pierwszym, oryginalnym jÄ™zyku z tej rodziny) potÄ™gowanie byÅ‚o reprezentowane za pomocÄ… znaku â†‘ (strzaÅ‚ka w gÃ³rÄ™). Podobnie byÅ‚o w kolejnych wersjach jÄ™zyka BASIC, ale z czasem znak â†‘ zniknÄ…Å‚ z klawiatur, a pojawiÅ‚ siÄ™ dobrze nam znany â€daszekâ€ (kareta), ktÃ³ry jednak wizualnie podobny jest do poprzednika â€“ zostaÅ‚ wiÄ™c zaadoptowany w jÄ™zykach z rodziny BASIC do oznaczenia operacji potÄ™gowania.]. Innym przykÅ‚adem moÅ¼e byÄ‡ doÅ›Ä‡ charakterystyczny operator ===, wystÄ™pujÄ…cy wÂ tej postaci m.in. wÂ jÄ™zykach PHP, ActionScript oraz JavaScript, ktÃ³ry oznacza rÃ³wnoÅ›Ä‡ co do wartoÅ›ci oraz typu footnote:[W jÄ™zykach o stosunkowo sÅ‚abym typowaniu moÅ¼liwe jest porÃ³wnanie zmiennych o bardzo rÃ³Å¼nych typach, operacja rÃ³wnoÅ›ci co do wartoÅ›ci jest wiÄ™c zazwyczaj niewystarczajÄ…ca.].

OczywiÅ›cie, im bardziej zagÅ‚Ä™bimy siÄ™ wÂ dany jÄ™zyk, tym wiÄ™cej charakterystycznych wyraÅ¼eÅ„ dla niego znajdziemy. PrzykÅ‚adem moÅ¼e byÄ‡ doÅ›Ä‡ nietypowe uÅ¼ycie operatora << przy wypisywaniu danych na standardowe wyjÅ›cie wÂ C++: +
`std::cout << 1234 << std::endl;`

PodsumowujÄ…c: wÂ wiÄ™kszoÅ›ci przypadkÃ³w rÃ³Å¼nice pomiÄ™dzy jÄ™zykami sprowadzajÄ… siÄ™ do kosmetyki, co znacznie uÅ‚atwia iÂ przyspiesza analizÄ™ obcego kodu. WÂ przypadku nieznanych wyraÅ¼eÅ„ moÅ¼emy zawsze siÄ™gnÄ…Ä‡ do dokumentacji lub kursÃ³w poÅ›wiÄ™conych danemu jÄ™zykowi programowania. Gorzej jest wÂ przypadku tzw. faÅ‚szywych przyjaciÃ³Å‚ (false friends), czyli wyraÅ¼eÅ„ wyglÄ…dajÄ…cych tak samo jak zapisy ze znanego nam jÄ™zyka, ale jednak oznaczajÄ…cych coÅ› innego â€“ wÂ kaÅ¼dym momencie analizy naleÅ¼y podchodziÄ‡ wiÄ™c zÂ pewnym dystansem do wyciÄ…gniÄ™tych wnioskÃ³w iÂ wÂ razie potrzeby je weryfikowaÄ‡.

==== Studium przypadku
OpierajÄ…c siÄ™ na opisanych prawidÅ‚owoÅ›ciach iÂ wskazÃ³wkach, przeanalizujmy wspÃ³lnie przykÅ‚adowy fragment kodu. CzytelnikÃ³w nieznajÄ…cych jÄ™zykÃ³w zÂ rodziny C/C++ zachÄ™cam do prÃ³by wykonania analizy we wÅ‚asnym zakresie, aÂ potem porÃ³wnania wnioskÃ³w zÂ moimi, wskazanymi dalej. WÂ analizie pominÄ™ wszystkie informacje, do ktÃ³rych wywnioskowania potrzebna jest znajomoÅ›Ä‡ danego jÄ™zyka; ujmÄ™ natomiast pewne wnioski, do jakich moÅ¼na dojÅ›Ä‡, posiadajÄ…c ogÃ³lnÄ… wiedzÄ™ zÂ informatyki iÂ programowania (na potrzeby analizy przyjmÄ™ zaÅ‚oÅ¼enie, Å¼e czytelnik dysponuje podstawowÄ… wiedzÄ… zÂ tej dziedziny). Dodatkowo przy kaÅ¼dym wniosku wskaÅ¼Ä™, ktÃ³ra metoda pozwoliÅ‚a mi do niego dojÅ›Ä‡; zaznaczÄ™ rÃ³wnieÅ¼ konkluzje, ktÃ³re poczÄ…tkowo wydawaÅ‚y siÄ™ poprawne, ale takimi ostatecznie nie byÅ‚y. WÂ tym celu posÅ‚uÅ¼Ä™ siÄ™ nastÄ™pujÄ…cymi oznaczeniami:

* *{WO}* â€“ wniosek wyciÄ…gniÄ™ty dziÄ™ki wiedzy ogÃ³lnej oÂ informatyce iÂ programowaniu;
* *{A}* â€“ zachowanie analogiczne lub identyczne ze spotykanymi wÂ innych jÄ™zykach programowania, czyli â€podobne wyraÅ¼enie widziaÅ‚em juÅ¼ wÂ innych jÄ™zykachâ€;
* *{TR}* â€“ wniosek wyciÄ…gniÄ™ty zÂ rozwiniÄ™cia skrÃ³tÃ³w iÂ przetÅ‚umaczenia nazwy/zwrotu zÂ jÄ™zyka angielskiego na jÄ™zyk polski;
* *{ERR}* â€“ wniosek, do ktÃ³rego doszedÅ‚em, jest bÅ‚Ä™dny (mimo Å¼e brzmi sensownie wÂ danym kontekÅ›cie).

Kod, na ktÃ³rym bÄ™dÄ™ pracowaÅ‚, wyglÄ…da nastÄ™pujÄ…co:

[source,cpp]
----
int calc_file_md5(const char *fname,
                  unsigned char result[16])
{
  FILE *f;
  MD5_CTX md5;
  char buffer[1024];
  size_t ret;
Â 
  f = fopen(fname, "rb");
  if (!f) {
    return -1;
  }
Â 
  MD5_Init(&md5);
Â 
  while(1) {
    ret = fread(buffer, 1, sizeof(buffer), f);
    if (ret == 0) {
      break;
    }
Â 
    MD5_Update(&md5, buffer, ret);
  }
Â 
  fclose(f);
  MD5_Final(result, &md5);
  return 0;
}
----

Zacznijmy od poczÄ…tku:

[source,cpp]
----
int calc_file_md5(const char *fname,
                  unsigned char result[16]) {
----
Bardzo duÅ¼o mÃ³wi nam juÅ¼ sama nazwa funkcji â€“ _calc_file_md5_, czyli â€wylicz MD5 plikuâ€{TR}. MD5 oczywiÅ›cie oznacza tutaj funkcjÄ™ skrÃ³tu, ktÃ³ra zÂ danych (bajtÃ³w) wylicza 128-bitowy hasz{WO}. OÂ ile po nazwie moÅ¼emy domyÅ›liÄ‡ siÄ™, jaki jest cel danej funkcji, to nadal pozostaje otwarte pytanie: wÂ jaki dokÅ‚adnie sposÃ³b realizuje swoje zadanie?

ZakÅ‚adajÄ…c, Å¼e parametry funkcji sÄ… wylistowane wÂ nawiasie{A}, mamy do czynienia zÂ dwoma parametrami:

* const char *fname â€“ biorÄ…c pod uwagÄ™, Å¼e wÂ nazwie funkcji pojawiÅ‚o siÄ™ sÅ‚owo â€fileâ€, przedrostek â€fâ€ pochodzi zapewne od niego. WÂ wolnym tÅ‚umaczeniu otrzymujemy wiÄ™c wyraÅ¼enie: â€staÅ‚y znak *nazwaplikuâ€{TR}. ZakÅ‚adam, Å¼e nie znamy znaczenia znaku gwiazdki wÂ tym wyraÅ¼eniu, wiÄ™c na razie jÄ… zignorujemy. ZÂ pozostaÅ‚ej czÄ™Å›ci moÅ¼emy wnioskowaÄ‡, Å¼e nazwapliku jest typu{A} staÅ‚y znak (tylko jeden?), co niestety ma niewiele sensu â€“ nazwy plikÃ³w prawie nigdy nie majÄ… tylko jednego znaku. BazujÄ…c na tym, moÅ¼na dojÅ›Ä‡ do wniosku, Å¼e zapewne chodzi oÂ staÅ‚y string lub wiele staÅ‚ych znakÃ³w (czyÅ¼by * oznaczaÅ‚o mnogoÅ›Ä‡?{WO, ERR} footnote:[W informatyce w wielu miejscach uÅ¼ywa siÄ™ znaku * do oznaczenia mnogoÅ›ci (np. w wyraÅ¼eniach regularnych, UML-u czy przy operowaniu na plikach z linii poleceÅ„), niemniej jednak w jÄ™zyku C znak * oznacza wskaÅºnik, a wiÄ™c poprawnym wnioskiem byÅ‚oby stwierdzenie, Å¼e â€nazwa pliku jest wskaÅºnikiem na zero lub wiÄ™cej znakÃ³wâ€.]).
* unsigned char result[16] â€“ sÅ‚owo â€resultâ€ (wynik){TR} jest oczywiste, natomiast reszta jest bardziej zagadkowa â€“ unsigned char to â€znak bez znakuâ€, aÂ raczej â€znak bez znaku matematycznegoâ€{TR}; gdyby zamiast char byÅ‚ np. int, moglibyÅ›my zaÅ‚oÅ¼yÄ‡, Å¼e mamy do czynienia zÂ liczbÄ… naturalnÄ…, ale jak siÄ™ ma do tego typ znakowy? Liczba wÂ nawiasie prawdopodobnie mÃ³wi oÂ dÅ‚ugoÅ›ci tablicy, co by siÄ™ zgadzaÅ‚o, poniewaÅ¼ moÅ¼emy zaÅ‚oÅ¼yÄ‡, Å¼e jeden znak zajmuje jeden bajt (czyli 8 bitÃ³w){WO}, aÂ wiÄ™c 128 bitÃ³w MD5 to akurat 16 bajtÃ³w. Dlaczego funkcja dostaje wynik juÅ¼ na poczÄ…tku? To nie ma oczywiÅ›cie sensu, wiÄ™c zapewne jest to jakiegoÅ› rodzaju referencja do zmiennej, do ktÃ³rej wynik ma zostaÄ‡ dopiero zapisany{A, WO}.

Pozostaje nam sÅ‚owo â€intâ€ przed nazwÄ… funkcji, ktÃ³re prawdopodobnie oznacza liczbÄ™ caÅ‚kowitÄ… (int, od integer){A, TR}. Åatwo moÅ¼na siÄ™ domyÅ›liÄ‡, Å¼e jest to typ zwracany funkcji {A, WO}.

[source,cpp]
----
FILE *f;
MD5_CTX md5;
char buffer[1024];
size_t ret;
----

WyglÄ…da na to, Å¼e wÂ powyÅ¼szych linijkach nie dzieje siÄ™ nic interesujÄ…cego â€“ nie widzimy wÂ nich Å¼adnych operacji matematycznych czy wywoÅ‚aÅ„ funkcji, wiÄ™c sÄ… to zapewne zmienne lokalne{A, WO}. Niemniej jednak przeanalizujmy poszczegÃ³lne deklaracje â€“ byÄ‡ moÅ¼e ich zrozumienie okaÅ¼e siÄ™ przydatne:

* FILE *f â€“ â€fileâ€ to plik{TR}, wiÄ™c zmienna f bÄ™dzie prawdopodobnie uÅ¼ywana jako uchwyt do pliku{WO, A}, co ma sens, biorÄ…c pod uwagÄ™ nazwÄ™ funkcji.
* MD5_CTX md5 â€“ skrÃ³t CTX pochodzi od sÅ‚owa â€kontekstâ€ (context){TR}, ktÃ³rym wÂ programowaniu oznacza siÄ™ zazwyczaj zestaw rÃ³Å¼nych elementÃ³w wchodzÄ…cych wÂ skÅ‚ad mniej lub bardziej szeroko rozumianego Å›rodowiska wykonania{WO}. Prawdopodobnie md5 bÄ™dzie wiÄ™c takim zestawem zmiennych poÅ›rednich uÅ¼ywanych przy wyliczaniu funkcji skrÃ³tu MD5 (aÅ¼ chce siÄ™ powiedzieÄ‡ â€obiektemâ€{A}).
* char buffer[1024] â€“ bufor 1024 znakÃ³w{A, WO, TR}.
* size_t ret â€“ poniewaÅ¼ mamy do czynienia zÂ typami zmiennych, sufiks â€tâ€ zapewne oznacza typ (type), aÂ wiÄ™c size_t moÅ¼e oznaczaÄ‡ â€typ [oznaczajÄ…cy] wielkoÅ›Ä‡â€{TR}. SÅ‚owem â€retâ€ czÄ™sto okreÅ›la siÄ™ tzw. return value{WO}, czyli moÅ¼emy zaÅ‚oÅ¼yÄ‡, Å¼e mamy do czynienia ze zmiennÄ…, wÂ ktÃ³rej bÄ™dzie przechowywana zwrÃ³cona wartoÅ›Ä‡{TR}, prawdopodobnie odnoszÄ…ca siÄ™ do pewnej wielkoÅ›ci. WÂ tym momencie zbyt wiele nam to nie mÃ³wi, ale zapewne wiÄ™cej dowiemy siÄ™, gdy zobaczymy, wÂ jaki sposÃ³b zmienna jest wykorzystywana wÂ kodzie.

[source,cpp]
----
f = fopen(fname, "rb");
if (!f) {
  return -1;
}
----

Jak juÅ¼ ustaliliÅ›my, â€fâ€ jest prefiksem sÅ‚owa â€fileâ€, wiÄ™c tÅ‚umaczÄ…c pierwszÄ… liniÄ™ na jÄ™zyk polski, otrzymujemy wyraÅ¼enie â€otwÃ³rz plik oÂ nazwie fnameâ€. TrochÄ™ bardziej zagadkowy moÅ¼e byÄ‡ ciÄ…g â€rbâ€. Litera r zapewne oznacza read, czyli â€odczytâ€{TR, A, WO}, ale b moÅ¼e stanowiÄ‡ zagadkÄ™. WÂ tym momencie wydaje siÄ™ to jednak maÅ‚o istotne, przejdÅºmy zatem dalej (alternatywnie moÅ¼na siÄ™gnÄ…Ä‡ do dokumentacji).

Wynik wywoÅ‚ania funkcji fopen jest zapisywany do zmiennej f, co potwierdza naszÄ… wczeÅ›niejszÄ… hipotezÄ™, Å¼e jest to prawdopodobnie rodzaj uchwytu do pliku{A}. PozostaÅ‚a czÄ™Å›Ä‡ kodu wyglÄ…da jak typowe sprawdzanie bÅ‚Ä™dÃ³w{A}, pomiÅ„my je wiÄ™c iÂ przejdÅºmy dalej.

[source,cpp]
----
MD5_Init(&md5);
----

Kolejne proste wyraÅ¼enie â€“ zainicjowanie kontekstu/obiektu md5{TR, A}.
[source,cpp]
----
while(1) {
  ret = fread(buffer, 1, sizeof(buffer), f);
  if (ret == 0) {
    break;
  }
----

PoczÄ…tek pÄ™tli jest oczywisty â€“ jest ona nieskoÅ„czona{A}, tj. bÄ™dzie wykonywana, dopÃ³ki 1 bÄ™dzie oznaczaÅ‚o wyraÅ¼enie prawdziwe {TR, WO}.

Dalej mamy do czynienia zÂ wywoÅ‚aniem funkcji fread â€“ â€czytaj plikâ€ {TR}, ktÃ³ra wÂ parametrach przyjmuje bufor, tajemniczÄ… jedynkÄ™ (ktÃ³rÄ… prawdopodobnie moÅ¼na zignorowaÄ‡), wielkoÅ›Ä‡ bufora (sizeof, czyli â€wielkoÅ›Ä‡â€{TR}) oraz uchwyt pliku. Jak moÅ¼emy siÄ™ domyÅ›liÄ‡, bufor zostanie wypeÅ‚niony danymi zÂ pliku.

Zwracany przez funkcjÄ™ fread wynik zostaje zapisany wÂ zmiennej ret (ktÃ³ra, jak pamiÄ™tamy, wyraÅ¼a pewnÄ… wielkoÅ›Ä‡). JeÅ›li chodzi oÂ naturÄ™ zwracanej wartoÅ›ci, to nie sÄ… to zapewne dane (te trafiajÄ… do bufora), prawdopodobnie bÄ™dzie to wiÄ™c iloÅ›Ä‡ faktycznie odczytanych danych{A}. MiaÅ‚oby to sens, szczegÃ³lnie biorÄ…c pod uwagÄ™ drugÄ… czÄ™Å›Ä‡ fragmentu, czyli opuszczenie pÄ™tli wÂ przypadku, gdy wielkoÅ›Ä‡ (liczba) odczytanych danych bÄ™dzie wynosiÅ‚a zero bajtÃ³w {A}.

[source,cpp]
----
MD5_Update(&md5, buffer, ret);
----

KoÅ„cÃ³wka pÄ™tli wyglÄ…da doÅ›Ä‡ prosto â€“ â€uaktualnij MD5â€{TR}; dane pobierz zÂ bufora wÂ iloÅ›ci odczytanej zÂ pliku.

[source,cpp]
----
fclose(f);
MD5_Final(result, &md5);
return 0;
----

Podobnie jest wÂ przypadku koÅ„cowego fragmentu kodu funkcji â€zamknij plikâ€{TR, A}, oraz prawdopodobnie â€zapisz/przekaÅ¼ finalny wynik MD5 do resultâ€, po czym opuÅ›Ä‡ funkcjÄ™, zwracajÄ…c 0.

PodsumowujÄ…c: funkcja liczy sumÄ™ MD5 pliku. WÂ tym celu otwiera plik, inicjuje obiekt kontekstu MD5, po czym uaktualnia wartoÅ›Ä‡ skrÃ³tu oÂ odczytywane dane. Na koniec zamyka otwarte uchwyty iÂ przekazuje dotychczasowo wyliczonÄ… sumÄ™ MD5 do tablicy result.

CaÅ‚kiem nieÅºle, jak na analizÄ™ kodu wÂ nieznanym jÄ™zyku.

==== Uwagi na koniec

PrzytoczonÄ… analizÄ™ przeprowadziÅ‚em, idÄ…c od poczÄ…tku funkcji wÂ kierunku jej koÅ„ca, po jednej lub kilka linii naraz; zachÄ™cam czytelnikÃ³w do wykonania kilku pierwszych analiz wÅ‚aÅ›nie wÂ ten sposÃ³b. WÂ praktyce jednak analizÄ™ czÄ™sto wykonuje siÄ™ inaczej: ignorujÄ…c wiÄ™kszoÅ›Ä‡ kodu, szukamy fragmentÃ³w, ktÃ³re nas interesujÄ… iÂ ktÃ³rych przeczytanie niesie ze sobÄ… stosunkowo duÅ¼Ä… porcjÄ™ informacji, aÂ nastÄ™pnie ewentualnie cofamy siÄ™ iÂ wykonujemy dodatkowÄ… analizÄ™, uzupeÅ‚niajÄ…c brakujÄ…cÄ… wiedzÄ™ (np. sprawdzajÄ…c typ zmiennej, sposÃ³b jej inicjalizacji czy to, jak wczeÅ›niej byÅ‚a uÅ¼ywana). Bardzo wiele oÂ funkcji mÃ³wi juÅ¼ to, jakie inne funkcje iÂ metody sÄ… przez niÄ… wywoÅ‚ywane (zachÄ™cam do spojrzenia pod tym kÄ…tem na kod, ktÃ³ry wczeÅ›niej analizowaliÅ›my). ZÂ drugiej strony, analizÄ™ niektÃ³rych fragmentÃ³w moÅ¼emy pominÄ…Ä‡, poniewaÅ¼ rzadko kiedy przynoszÄ… interesujÄ…ce nas informacje â€“ przykÅ‚adem moÅ¼e byÄ‡ obsÅ‚uga bÅ‚Ä™dÃ³w (zÂ pominiÄ™ciem komunikatÃ³w tekstowych wÂ nich zawartych), ktÃ³rÄ… czÄ™sto moÅ¼na zupeÅ‚nie przeskoczyÄ‡, tak jak zrobiÅ‚em to wÂ opisanym przykÅ‚adzie. Ostatecznie przebieg analizy zaleÅ¼y wÂ znacznym stopniu od jej celu â€“ wÂ tym rozdziale przyjÄ…Å‚em zaÅ‚oÅ¼enie, Å¼e podstawowym celem jest zrozumienie sposobu dziaÅ‚ania gÅ‚Ã³wnego algorytmu, ewentualnie przeÅ›ledzenie celu iÂ przeznaczenia parametrÃ³w funkcji. JeÅ›li naszym zadaniem jest jednak znalezienie bÅ‚Ä™du wÂ funkcji, to analiza moÅ¼e pÃ³jÅ›Ä‡ innym torem, aÂ przykÅ‚adowe fragmenty kodu odpowiedzialne za weryfikowanie poprawnoÅ›ci zwracanych wartoÅ›ci iÂ obsÅ‚ugiwanie bÅ‚Ä™dÃ³w bÄ™dÄ… wrÄ™cz kluczowe.

WÂ pozostaÅ‚ych rozdziaÅ‚ach ksiÄ…Å¼ki umieÅ›ciÅ‚em wiele listingÃ³w â€“ niektÃ³re zÂ nich sÄ… wÂ znacznym stopniu wyjaÅ›nione, ale wÂ czÄ™Å›ci przypadkÃ³w przyjÄ…Å‚em zaÅ‚oÅ¼enie, iÅ¼ czytelnik wykona ich analizÄ™ we wÅ‚asnym zakresie, na przykÅ‚ad korzystajÄ…c zÂ wiedzy zdobytej wÂ tym rozdziale.

==== Ä†wiczenie - WÂ sposÃ³b analogiczny do opisanego wÂ tym rozdziale przeanalizuj poniÅ¼szy kod:

[source,cpp]
----
class VecFont():
  def __init__(self):
    self.__gfx_engine = None
    self.__font = None
Â 
  def set_gfx_engine(self, gfx):
    self.__gfx_engine = gfx
Â 
  def load_font_from_string(self, font_string):
    # Note: The font string is aÂ DEFLATEd serialized array of glyphs. Each
    # glyph is an array of paths. Each path is an array of coordinates.
    # This must be deserialized into Python arrays.
    font_string = font_string.decode("zlib")
    data = iter(font_string)
# Read all letters.
    self.__font = []
    while True:
      number_of_paths = self.__read_uint8(data)
      if number_of_paths == 0:
        break
Â 
      paths = []
      for _ in xrange(number_of_paths):
        number_of_coords = self.__read_uint8(data)
        coords = []
        for _ in xrange(number_of_coords):
          coords.append((
              self.__read_float(data),   # X
              self.__read_float(data)))  # Y
        paths.append(coords)
Â 
      self.__font.append(paths)
Â 
  def render_string(self, text, sx, sy, font_size):
    character_x = sx
    character_y = sy
Â 
    for character in text:
      translate_x = self.render_char(
          ord(character), character_x, character_y, font_size)
      translate_x += int(0.1 * font_size)
Â 
      character_x += translate_x
Â 
  def render_char(self, ch, sx, sy, font_size):
    max_x = 0
    for paths in self.__font[ch]:

last = None
      for coords in paths:
        if coords[0] > max_x: max_x = coords[0]
Â 
        if last == None:  # Skip first point.
          last = coords
          continue
Â 
        self.__gfx_engine.draw_line(
            int(sx + last[0] * font_size),
            int(sy + last[1] * font_size),
            int(sx + coords[0] * font_size),
            int(sy + coords[1] * font_size))
Â 
        last = coords

    return int(max_x * font_size)
Â 
  def __read_uint8(self, data):
    return ord(data.next())
Â 
  def __read_float(self, data):
    b = ""
    for _ in xrange(4):
      b += data.next()
    return struct.unpack(">f", b)[0]
Â 
def test_vec_font():
  FONT = ("eJxNUiFQw0AQTL6BTFUcMg4Zh0z+BQJR0RkEIq6yghlkZR04XOtwrcO1Dp"
          "c6XOpwqcMVh2R381+amZ9NLrd3t3tvBhEe93T8ifxjj/27KRHkh91stsQ4"
          "ic4e91gU9rbZCef4ruvaDCvkqshbngubZmfT5xfharVm3HbdoWrbPVE570"
          "VBrBaLZeAn9nM0EoH4PZ2G40hAzAxZ9pzOaMVxA5Pnq67VCqgcxNSK0jz/"
          "wjIBRYg0wr5mmYMiFhPebLYOSuPU3rd7lQFVrajsoywVoyoy/D83whjXq7"
          "WbdIdYJstPHDkWTB6ebEfX4JhGpmN0iyzU5hZclmXCO/RlpUnvINFwCUws"
		  "PSG+DGqDUin3jVlGEugr2wBNEjI4gAqXvTj3gNUgZpimBlzFFJT/NWBe4e"
          "9spvmBbox54Q8zGSOq3LjXqjzPN3xhQihkTtctTGOxCFlOhMKE989eLZY2"
          "jJv1dV2e51xxnJb+YmtjfunaNe4aL4WaDvo7GqaSq38Mnx3i"). decode("base64")
Â 
  vf = VecFont()
  vf.load_font_from_string(FONT)
  vf.set_gfx_engine(TestGraphicsEngine())
  vf.render_string("\0\1\2\3\4\5\6\7\x08\x09\x0a\x0b", 100, 100, 70)
----

== Praktyczna praktyka - Astro
